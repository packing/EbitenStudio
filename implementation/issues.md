# 问题记录和解决方案

本文档记录实施过程中遇到的所有问题和解决方案。

---

## 问题模板

```markdown
### 问题 #N: [简短描述]

**发现时间**: YYYY-MM-DD  
**阶段**: Phase X  
**严重程度**: 🔴高 / 🟡中 / 🟢低  
**状态**: ⏳未解决 / 🔄处理中 / ✅已解决

**问题描述**:
[详细描述问题]

**重现步骤**:
1. ...
2. ...

**错误信息**:
```
[错误日志]
```

**分析**:
[问题原因分析]

**解决方案**:
[如何解决]

**代码变更**:
- 文件: xxx
- 行号: xxx
- 变更: xxx

**验证**:
- [ ] 测试通过
- [ ] 文档更新

---
```

---

## Phase 1 问题

### 问题 #1: EventQueue缓冲大小选择

**发现时间**: 2025-12-26  
**阶段**: Phase 1  
**严重程度**: 🟡中  
**状态**: ✅已解决

**问题描述**:
EventQueue使用channel实现，需要确定合适的缓冲大小。缓冲太小会导致主线程阻塞，太大则浪费内存。

**分析**:
- 典型UI交互：每秒最多50-100个事件
- 脚本处理速度：每个事件约1-5ms
- 需要一定缓冲应对突发事件（如快速点击）

**解决方案**:
1. 设置缓冲为100个事件
2. Push使用select非阻塞，队列满时丢弃事件并记录日志
3. 添加配置选项允许调整缓冲大小

**代码变更**:
- 文件: `ui/event_queue.go`
- 行号: 32
- 变更: `ch: make(chan WidgetEvent, 100)`

**验证**:
- [x] 压力测试通过（1000事件/秒）
- [x] 文档更新

---

### 问题 #2: CommandQueue是否需要互斥锁

**发现时间**: 2025-12-26  
**阶段**: Phase 1  
**严重程度**: 🔴高  
**状态**: ✅已解决

**问题描述**:
CommandQueue的Push在脚本协程调用，PopAll在主线程调用，存在潜在的竞态条件。

**分析**:
虽然按设计脚本引擎运行在单一协程中，但：
1. 未来可能支持多个脚本协程
2. Go的race detector会报警
3. 显式加锁更安全

**解决方案**:
使用`sync.Mutex`保护CommandQueue的所有方法：
- Push()
- PopAll()
- Len()
- Clear()

**代码变更**:
- 文件: `ui/command_queue.go`
- 行号: 全局
- 变更: 添加`mu sync.Mutex`并在所有方法中使用

**验证**:
- [x] 并发测试通过（10协程并发）
- [x] Race detector无警告
- [x] 文档更新

---

## Phase 2 问题

_(待记录)_

---

## Phase 3 问题

_(待记录)_

---

## Phase 4 问题

_(待记录)_

---

## Phase 5 问题

_(待记录)_

---

## Phase 6 问题

_(待记录)_

---

## Phase 7 问题

_(待记录)_

---

## 问题统计

| 阶段 | 高 | 中 | 低 | 总计 | 已解决 | 未解决 |
|------|----|----|----|----|--------|--------|
| Phase 1 | 1 | 1 | 0 | 2 | 2 | 0 |
| Phase 2 | 0 | 0 | 0 | 0 | 0 | 0 |
| Phase 3 | 0 | 0 | 0 | 0 | 0 | 0 |
| Phase 4 | 0 | 0 | 0 | 0 | 0 | 0 |
| Phase 5 | 0 | 0 | 0 | 0 | 0 | 0 |
| Phase 6 | 0 | 0 | 0 | 0 | 0 | 0 |
| Phase 7 | 0 | 0 | 0 | 0 | 0 | 0 |
| **总计** | **1** | **1** | **0** | **2** | **2** | **0** |

---

最后更新：2025年12月26日
